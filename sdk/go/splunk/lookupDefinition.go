// Code generated by the Pulumi Terraform Bridge (tfgen) Tool DO NOT EDIT.
// *** WARNING: Do not edit by hand unless you're certain you know what you are doing! ***

package splunk

import (
	"context"
	"reflect"

	"errors"
	"github.com/pulumi/pulumi-splunk/sdk/go/splunk/internal"
	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
)

// ##
//
// # Resource: LookupDefinition
//
// Manage lookup definitions in Splunk. For more information on lookup definitions, refer to the official Splunk documentation: https://docs.splunk.com/Documentation/Splunk/latest/Knowledge/Aboutlookupsandfieldactions
//
// ## Example Usage
//
// ```go
// package main
//
// import (
//
//	"github.com/pulumi/pulumi-splunk/sdk/go/splunk"
//	"github.com/pulumi/pulumi/sdk/v3/go/pulumi"
//
// )
//
//	func main() {
//		pulumi.Run(func(ctx *pulumi.Context) error {
//			_, err := splunk.NewLookupDefinition(ctx, "example", &splunk.LookupDefinitionArgs{
//				Name:     pulumi.String("example_lookup_definition"),
//				Filename: pulumi.String("example_lookup_file.csv"),
//				Acl: &splunk.LookupDefinitionAclArgs{
//					Owner:   pulumi.String("admin"),
//					App:     pulumi.String("search"),
//					Sharing: pulumi.String("app"),
//					Reads: pulumi.StringArray{
//						pulumi.String("*"),
//					},
//					Writes: pulumi.StringArray{
//						pulumi.String("admin"),
//					},
//				},
//			})
//			if err != nil {
//				return err
//			}
//			return nil
//		})
//	}
//
// ```
//
// ## Validation Rules
//
// When `acl.sharing` is set to `user`, the `acl.read` and `acl.write` fields must not be explicitly set. Setting them will trigger a validation error.
type LookupDefinition struct {
	pulumi.CustomResourceState

	// Defines the access control list (ACL) for the lookup definition. See acl.md for more details.
	Acl LookupDefinitionAclOutput `pulumi:"acl"`
	// The filename for the lookup table, usually ending in `.csv`.
	Filename pulumi.StringOutput `pulumi:"filename"`
	// A unique name for the lookup definition within the app context.
	Name pulumi.StringOutput `pulumi:"name"`
}

// NewLookupDefinition registers a new resource with the given unique name, arguments, and options.
func NewLookupDefinition(ctx *pulumi.Context,
	name string, args *LookupDefinitionArgs, opts ...pulumi.ResourceOption) (*LookupDefinition, error) {
	if args == nil {
		return nil, errors.New("missing one or more required arguments")
	}

	if args.Filename == nil {
		return nil, errors.New("invalid value for required argument 'Filename'")
	}
	if args.Name == nil {
		return nil, errors.New("invalid value for required argument 'Name'")
	}
	opts = internal.PkgResourceDefaultOpts(opts)
	var resource LookupDefinition
	err := ctx.RegisterResource("splunk:index/lookupDefinition:LookupDefinition", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetLookupDefinition gets an existing LookupDefinition resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetLookupDefinition(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *LookupDefinitionState, opts ...pulumi.ResourceOption) (*LookupDefinition, error) {
	var resource LookupDefinition
	err := ctx.ReadResource("splunk:index/lookupDefinition:LookupDefinition", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering LookupDefinition resources.
type lookupDefinitionState struct {
	// Defines the access control list (ACL) for the lookup definition. See acl.md for more details.
	Acl *LookupDefinitionAcl `pulumi:"acl"`
	// The filename for the lookup table, usually ending in `.csv`.
	Filename *string `pulumi:"filename"`
	// A unique name for the lookup definition within the app context.
	Name *string `pulumi:"name"`
}

type LookupDefinitionState struct {
	// Defines the access control list (ACL) for the lookup definition. See acl.md for more details.
	Acl LookupDefinitionAclPtrInput
	// The filename for the lookup table, usually ending in `.csv`.
	Filename pulumi.StringPtrInput
	// A unique name for the lookup definition within the app context.
	Name pulumi.StringPtrInput
}

func (LookupDefinitionState) ElementType() reflect.Type {
	return reflect.TypeOf((*lookupDefinitionState)(nil)).Elem()
}

type lookupDefinitionArgs struct {
	// Defines the access control list (ACL) for the lookup definition. See acl.md for more details.
	Acl *LookupDefinitionAcl `pulumi:"acl"`
	// The filename for the lookup table, usually ending in `.csv`.
	Filename string `pulumi:"filename"`
	// A unique name for the lookup definition within the app context.
	Name string `pulumi:"name"`
}

// The set of arguments for constructing a LookupDefinition resource.
type LookupDefinitionArgs struct {
	// Defines the access control list (ACL) for the lookup definition. See acl.md for more details.
	Acl LookupDefinitionAclPtrInput
	// The filename for the lookup table, usually ending in `.csv`.
	Filename pulumi.StringInput
	// A unique name for the lookup definition within the app context.
	Name pulumi.StringInput
}

func (LookupDefinitionArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*lookupDefinitionArgs)(nil)).Elem()
}

type LookupDefinitionInput interface {
	pulumi.Input

	ToLookupDefinitionOutput() LookupDefinitionOutput
	ToLookupDefinitionOutputWithContext(ctx context.Context) LookupDefinitionOutput
}

func (*LookupDefinition) ElementType() reflect.Type {
	return reflect.TypeOf((**LookupDefinition)(nil)).Elem()
}

func (i *LookupDefinition) ToLookupDefinitionOutput() LookupDefinitionOutput {
	return i.ToLookupDefinitionOutputWithContext(context.Background())
}

func (i *LookupDefinition) ToLookupDefinitionOutputWithContext(ctx context.Context) LookupDefinitionOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LookupDefinitionOutput)
}

// LookupDefinitionArrayInput is an input type that accepts LookupDefinitionArray and LookupDefinitionArrayOutput values.
// You can construct a concrete instance of `LookupDefinitionArrayInput` via:
//
//	LookupDefinitionArray{ LookupDefinitionArgs{...} }
type LookupDefinitionArrayInput interface {
	pulumi.Input

	ToLookupDefinitionArrayOutput() LookupDefinitionArrayOutput
	ToLookupDefinitionArrayOutputWithContext(context.Context) LookupDefinitionArrayOutput
}

type LookupDefinitionArray []LookupDefinitionInput

func (LookupDefinitionArray) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*LookupDefinition)(nil)).Elem()
}

func (i LookupDefinitionArray) ToLookupDefinitionArrayOutput() LookupDefinitionArrayOutput {
	return i.ToLookupDefinitionArrayOutputWithContext(context.Background())
}

func (i LookupDefinitionArray) ToLookupDefinitionArrayOutputWithContext(ctx context.Context) LookupDefinitionArrayOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LookupDefinitionArrayOutput)
}

// LookupDefinitionMapInput is an input type that accepts LookupDefinitionMap and LookupDefinitionMapOutput values.
// You can construct a concrete instance of `LookupDefinitionMapInput` via:
//
//	LookupDefinitionMap{ "key": LookupDefinitionArgs{...} }
type LookupDefinitionMapInput interface {
	pulumi.Input

	ToLookupDefinitionMapOutput() LookupDefinitionMapOutput
	ToLookupDefinitionMapOutputWithContext(context.Context) LookupDefinitionMapOutput
}

type LookupDefinitionMap map[string]LookupDefinitionInput

func (LookupDefinitionMap) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*LookupDefinition)(nil)).Elem()
}

func (i LookupDefinitionMap) ToLookupDefinitionMapOutput() LookupDefinitionMapOutput {
	return i.ToLookupDefinitionMapOutputWithContext(context.Background())
}

func (i LookupDefinitionMap) ToLookupDefinitionMapOutputWithContext(ctx context.Context) LookupDefinitionMapOutput {
	return pulumi.ToOutputWithContext(ctx, i).(LookupDefinitionMapOutput)
}

type LookupDefinitionOutput struct{ *pulumi.OutputState }

func (LookupDefinitionOutput) ElementType() reflect.Type {
	return reflect.TypeOf((**LookupDefinition)(nil)).Elem()
}

func (o LookupDefinitionOutput) ToLookupDefinitionOutput() LookupDefinitionOutput {
	return o
}

func (o LookupDefinitionOutput) ToLookupDefinitionOutputWithContext(ctx context.Context) LookupDefinitionOutput {
	return o
}

// Defines the access control list (ACL) for the lookup definition. See acl.md for more details.
func (o LookupDefinitionOutput) Acl() LookupDefinitionAclOutput {
	return o.ApplyT(func(v *LookupDefinition) LookupDefinitionAclOutput { return v.Acl }).(LookupDefinitionAclOutput)
}

// The filename for the lookup table, usually ending in `.csv`.
func (o LookupDefinitionOutput) Filename() pulumi.StringOutput {
	return o.ApplyT(func(v *LookupDefinition) pulumi.StringOutput { return v.Filename }).(pulumi.StringOutput)
}

// A unique name for the lookup definition within the app context.
func (o LookupDefinitionOutput) Name() pulumi.StringOutput {
	return o.ApplyT(func(v *LookupDefinition) pulumi.StringOutput { return v.Name }).(pulumi.StringOutput)
}

type LookupDefinitionArrayOutput struct{ *pulumi.OutputState }

func (LookupDefinitionArrayOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*[]*LookupDefinition)(nil)).Elem()
}

func (o LookupDefinitionArrayOutput) ToLookupDefinitionArrayOutput() LookupDefinitionArrayOutput {
	return o
}

func (o LookupDefinitionArrayOutput) ToLookupDefinitionArrayOutputWithContext(ctx context.Context) LookupDefinitionArrayOutput {
	return o
}

func (o LookupDefinitionArrayOutput) Index(i pulumi.IntInput) LookupDefinitionOutput {
	return pulumi.All(o, i).ApplyT(func(vs []interface{}) *LookupDefinition {
		return vs[0].([]*LookupDefinition)[vs[1].(int)]
	}).(LookupDefinitionOutput)
}

type LookupDefinitionMapOutput struct{ *pulumi.OutputState }

func (LookupDefinitionMapOutput) ElementType() reflect.Type {
	return reflect.TypeOf((*map[string]*LookupDefinition)(nil)).Elem()
}

func (o LookupDefinitionMapOutput) ToLookupDefinitionMapOutput() LookupDefinitionMapOutput {
	return o
}

func (o LookupDefinitionMapOutput) ToLookupDefinitionMapOutputWithContext(ctx context.Context) LookupDefinitionMapOutput {
	return o
}

func (o LookupDefinitionMapOutput) MapIndex(k pulumi.StringInput) LookupDefinitionOutput {
	return pulumi.All(o, k).ApplyT(func(vs []interface{}) *LookupDefinition {
		return vs[0].(map[string]*LookupDefinition)[vs[1].(string)]
	}).(LookupDefinitionOutput)
}

func init() {
	pulumi.RegisterInputType(reflect.TypeOf((*LookupDefinitionInput)(nil)).Elem(), &LookupDefinition{})
	pulumi.RegisterInputType(reflect.TypeOf((*LookupDefinitionArrayInput)(nil)).Elem(), LookupDefinitionArray{})
	pulumi.RegisterInputType(reflect.TypeOf((*LookupDefinitionMapInput)(nil)).Elem(), LookupDefinitionMap{})
	pulumi.RegisterOutputType(LookupDefinitionOutput{})
	pulumi.RegisterOutputType(LookupDefinitionArrayOutput{})
	pulumi.RegisterOutputType(LookupDefinitionMapOutput{})
}
